{"code":"import { generateMnemonic as generateBip39Mnemonic, mnemonicToSeed } from 'bip39';\r\nimport { randomBytes } from 'blockstack/lib/encryption/cryptoRandom';\r\nimport { bip32 } from 'bitcoinjs-lib';\r\nimport { encrypt } from '../encryption/encrypt';\r\nimport { encryptMnemonic } from 'blockstack';\r\nexport async function generateMnemonicRootKeychain(entropy) {\r\n    const plaintextMnemonic = generateBip39Mnemonic(entropy, randomBytes);\r\n    const seedBuffer = await mnemonicToSeed(plaintextMnemonic);\r\n    const rootNode = bip32.fromSeed(seedBuffer);\r\n    return {\r\n        rootNode,\r\n        plaintextMnemonic,\r\n    };\r\n}\r\nexport async function generateEncryptedMnemonicRootKeychain(password, entropy) {\r\n    const plaintextMnemonic = generateBip39Mnemonic(entropy, randomBytes);\r\n    const seedBuffer = await mnemonicToSeed(plaintextMnemonic);\r\n    const rootNode = bip32.fromSeed(seedBuffer);\r\n    const ciphertextBuffer = await encrypt(plaintextMnemonic, password);\r\n    const encryptedMnemonicPhrase = ciphertextBuffer.toString('hex');\r\n    return {\r\n        rootNode,\r\n        encryptedMnemonicPhrase,\r\n    };\r\n}\r\nexport async function deriveRootKeychainFromMnemonic(plaintextMnemonic) {\r\n    const seedBuffer = await mnemonicToSeed(plaintextMnemonic);\r\n    const rootNode = bip32.fromSeed(seedBuffer);\r\n    return rootNode;\r\n}\r\nexport async function encryptMnemonicFormatted(plaintextMnemonic, password) {\r\n    const encryptedMnemonic = await encryptMnemonic(plaintextMnemonic, password);\r\n    const encryptedMnemonicHex = encryptedMnemonic.toString('hex');\r\n    return { encryptedMnemonic, encryptedMnemonicHex };\r\n}\r\n//# sourceMappingURL=index.js.map","references":["/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/bip39/types/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/encryption/cryptoRandom.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/node_modules/bitcoinjs-lib/types/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/encryption/encrypt.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/index.d.ts"],"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/mnemonic/index.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,gBAAgB,IAAI,qBAAqB,EAAE,cAAc,EAAE,MAAM,OAAO,CAAC;AAClF,OAAO,EAAE,WAAW,EAAE,MAAM,wCAAwC,CAAC;AACrE,OAAO,EAAE,KAAK,EAAE,MAAM,eAAe,CAAC;AAEtC,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAI7C,MAAM,CAAC,KAAK,UAAU,4BAA4B,CAAC,OAA8B;IAC/E,MAAM,iBAAiB,GAAG,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IACtE,MAAM,UAAU,GAAG,MAAM,cAAc,CAAC,iBAAiB,CAAC,CAAC;IAC3D,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAC5C,OAAO;QACL,QAAQ;QACR,iBAAiB;KAClB,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,qCAAqC,CACzD,QAAgB,EAChB,OAA8B;IAE9B,MAAM,iBAAiB,GAAG,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IACtE,MAAM,UAAU,GAAG,MAAM,cAAc,CAAC,iBAAiB,CAAC,CAAC;IAC3D,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAC5C,MAAM,gBAAgB,GAAG,MAAM,OAAO,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;IACpE,MAAM,uBAAuB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACjE,OAAO;QACL,QAAQ;QACR,uBAAuB;KACxB,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAAC,iBAAyB;IAC5E,MAAM,UAAU,GAAG,MAAM,cAAc,CAAC,iBAAiB,CAAC,CAAC;IAC3D,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAC5C,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,wBAAwB,CAAC,iBAAyB,EAAE,QAAgB;IACxF,MAAM,iBAAiB,GAAG,MAAM,eAAe,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;IAC7E,MAAM,oBAAoB,GAAG,iBAAiB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC/D,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,CAAC;AACrD,CAAC\"}","dts":{"name":"/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/mnemonic/index.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"node\" />\r\nimport { bip32 } from 'bitcoinjs-lib';\r\nexport declare type AllowedKeyEntropyBits = 128 | 256;\r\nexport declare function generateMnemonicRootKeychain(entropy: AllowedKeyEntropyBits): Promise<{\r\n    rootNode: bip32.BIP32Interface;\r\n    plaintextMnemonic: string;\r\n}>;\r\nexport declare function generateEncryptedMnemonicRootKeychain(password: string, entropy: AllowedKeyEntropyBits): Promise<{\r\n    rootNode: bip32.BIP32Interface;\r\n    encryptedMnemonicPhrase: string;\r\n}>;\r\nexport declare function deriveRootKeychainFromMnemonic(plaintextMnemonic: string): Promise<bip32.BIP32Interface>;\r\nexport declare function encryptMnemonicFormatted(plaintextMnemonic: string, password: string): Promise<{\r\n    encryptedMnemonic: Buffer;\r\n    encryptedMnemonicHex: string;\r\n}>;\r\n"}}
