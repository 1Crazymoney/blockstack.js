{"code":"import { mnemonicToSeed } from 'bip39';\r\nimport { bip32 } from 'bitcoinjs-lib';\r\nimport { getBlockchainIdentities, makeIdentity, assertIsTruthy, recursiveRestoreIdentities, } from '../utils';\r\nimport Identity from '../identity';\r\nimport { decrypt } from '../encryption/decrypt';\r\nimport { connectToGaiaHub, encryptContent, getPublicKeyFromPrivate, decryptContent, } from 'blockstack';\r\nimport { generateEncryptedMnemonicRootKeychain, deriveRootKeychainFromMnemonic, encryptMnemonicFormatted, } from '../mnemonic';\r\nimport { deriveStxAddressChain } from '../address-derivation';\r\nimport { makeReadOnlyGaiaConfig, DEFAULT_GAIA_HUB, uploadToGaiaHub } from '../utils/gaia';\r\nimport { WalletSigner } from './signer';\r\nconst CONFIG_INDEX = 45;\r\nexport class Wallet {\r\n    constructor({ chain, encryptedBackupPhrase, identityPublicKeychain, bitcoinPublicKeychain, firstBitcoinAddress, identityKeypairs, identityAddresses, identities, configPrivateKey, stacksPrivateKey, walletConfig, }) {\r\n        this.chain = chain;\r\n        this.encryptedBackupPhrase = encryptedBackupPhrase;\r\n        this.identityPublicKeychain = identityPublicKeychain;\r\n        this.bitcoinPublicKeychain = bitcoinPublicKeychain;\r\n        this.firstBitcoinAddress = firstBitcoinAddress;\r\n        this.identityKeypairs = identityKeypairs;\r\n        this.identityAddresses = identityAddresses;\r\n        this.identities = identities.map(identity => new Identity(identity));\r\n        this.configPrivateKey = configPrivateKey;\r\n        this.stacksPrivateKey = stacksPrivateKey;\r\n        this.walletConfig = walletConfig;\r\n    }\r\n    static generateFactory(bitsEntropy) {\r\n        return async (password, chain) => {\r\n            const { rootNode, encryptedMnemonicPhrase } = await generateEncryptedMnemonicRootKeychain(password, bitsEntropy);\r\n            return this.createAccount({\r\n                encryptedBackupPhrase: encryptedMnemonicPhrase,\r\n                rootNode,\r\n                chain,\r\n            });\r\n        };\r\n    }\r\n    static async generate(password, chain) {\r\n        return await this.generateFactory(128)(password, chain);\r\n    }\r\n    static async generateStrong(password, chain) {\r\n        return await this.generateFactory(256)(password, chain);\r\n    }\r\n    static async restore(password, seedPhrase, chain) {\r\n        const rootNode = await deriveRootKeychainFromMnemonic(seedPhrase);\r\n        const { encryptedMnemonicHex } = await encryptMnemonicFormatted(seedPhrase, password);\r\n        const wallet = await Wallet.createAccount({\r\n            encryptedBackupPhrase: encryptedMnemonicHex,\r\n            rootNode,\r\n            chain,\r\n        });\r\n        return await wallet.restoreIdentities({ rootNode, gaiaReadURL: DEFAULT_GAIA_HUB });\r\n    }\r\n    static async createAccount({ encryptedBackupPhrase, rootNode, chain, identitiesToGenerate = 1, }) {\r\n        const derivedIdentitiesKey = rootNode.deriveHardened(CONFIG_INDEX).privateKey;\r\n        if (!derivedIdentitiesKey) {\r\n            throw new TypeError('Unable to derive config key for wallet identities');\r\n        }\r\n        const configPrivateKey = derivedIdentitiesKey.toString('hex');\r\n        const { childKey: stxAddressKeychain } = deriveStxAddressChain(chain)(rootNode);\r\n        const walletAttrs = await getBlockchainIdentities(rootNode, identitiesToGenerate);\r\n        return new Wallet({\r\n            ...walletAttrs,\r\n            chain,\r\n            configPrivateKey,\r\n            stacksPrivateKey: stxAddressKeychain.toBase58(),\r\n            encryptedBackupPhrase,\r\n        });\r\n    }\r\n    /**\r\n     * Restore all previously used identities. This is meant to be used when 'restoring' a wallet.\r\n     * First, it will check for a `walletConfig`. If present, then we use that to determine how\r\n     * many identities to generate, and auto-populate their username.\r\n     *\r\n     * If `walletConfig` is empty, then this is being restored from an authenticator that doesn't\r\n     * support `walletConfig`. In that case, we will recursively generate identities, and check for\r\n     * on-chain names.\r\n     *\r\n     */\r\n    async restoreIdentities({ rootNode, gaiaReadURL, }) {\r\n        const gaiaConfig = makeReadOnlyGaiaConfig({\r\n            readURL: gaiaReadURL,\r\n            privateKey: this.configPrivateKey,\r\n        });\r\n        await this.fetchConfig(gaiaConfig);\r\n        if (this.walletConfig) {\r\n            const getIdentities = this.walletConfig.identities.map(async (identityConfig, index) => {\r\n                let identity = this.identities[index];\r\n                if (!identity) {\r\n                    identity = await makeIdentity(rootNode, index);\r\n                }\r\n                if (identityConfig.username) {\r\n                    identity.usernames = [identityConfig.username];\r\n                    identity.defaultUsername = identityConfig.username;\r\n                }\r\n                return identity;\r\n            });\r\n            const identities = await Promise.all(getIdentities);\r\n            this.identities = identities;\r\n            return this;\r\n        }\r\n        await this.identities[0].refresh();\r\n        const newIdentities = await recursiveRestoreIdentities({ rootNode });\r\n        this.identities = this.identities.concat(newIdentities);\r\n        return this;\r\n    }\r\n    async createNewIdentity(password) {\r\n        const plainTextBuffer = await decrypt(Buffer.from(this.encryptedBackupPhrase, 'hex'), password);\r\n        const seed = await mnemonicToSeed(plainTextBuffer);\r\n        const rootNode = bip32.fromSeed(seed);\r\n        const index = this.identities.length;\r\n        const identity = await makeIdentity(rootNode, index);\r\n        this.identities.push(identity);\r\n        this.identityKeypairs.push(identity.keyPair);\r\n        this.identityAddresses.push(identity.address);\r\n        return identity;\r\n    }\r\n    async createGaiaConfig(gaiaHubUrl) {\r\n        return connectToGaiaHub(gaiaHubUrl, this.configPrivateKey);\r\n    }\r\n    async fetchConfig(gaiaConfig) {\r\n        try {\r\n            const response = await fetch(`${gaiaConfig.url_prefix}${gaiaConfig.address}/wallet-config.json`);\r\n            const encrypted = await response.text();\r\n            const configJSON = (await decryptContent(encrypted, {\r\n                privateKey: this.configPrivateKey,\r\n            }));\r\n            const config = JSON.parse(configJSON);\r\n            this.walletConfig = config;\r\n            return config;\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n    async getOrCreateConfig({ gaiaConfig, skipUpload, }) {\r\n        if (this.walletConfig) {\r\n            return this.walletConfig;\r\n        }\r\n        const config = await this.fetchConfig(gaiaConfig);\r\n        if (config) {\r\n            return config;\r\n        }\r\n        const newConfig = {\r\n            identities: this.identities.map(i => ({\r\n                username: i.defaultUsername,\r\n                address: i.address,\r\n                apps: {},\r\n            })),\r\n        };\r\n        this.walletConfig = newConfig;\r\n        if (!skipUpload) {\r\n            await this.updateConfig(gaiaConfig);\r\n        }\r\n        return newConfig;\r\n    }\r\n    async updateConfig(gaiaConfig) {\r\n        const publicKey = getPublicKeyFromPrivate(this.configPrivateKey);\r\n        const encrypted = await encryptContent(JSON.stringify(this.walletConfig), { publicKey });\r\n        await uploadToGaiaHub('wallet-config.json', encrypted, gaiaConfig);\r\n    }\r\n    async updateConfigWithAuth({ identityIndex, app, gaiaConfig, }) {\r\n        const { walletConfig } = this;\r\n        assertIsTruthy(walletConfig);\r\n        this.identities.forEach((identity, index) => {\r\n            const configIdentity = walletConfig.identities[index];\r\n            if (configIdentity) {\r\n                configIdentity.apps = configIdentity.apps || {};\r\n                configIdentity.username = identity.defaultUsername;\r\n                configIdentity.address = identity.address;\r\n                walletConfig.identities[index] = configIdentity;\r\n            }\r\n            else {\r\n                this.walletConfig?.identities.push({\r\n                    username: identity.defaultUsername,\r\n                    address: identity.address,\r\n                    apps: {},\r\n                });\r\n            }\r\n        });\r\n        const identity = walletConfig.identities[identityIndex];\r\n        identity.apps = identity.apps || {};\r\n        identity.apps[app.origin] = app;\r\n        walletConfig.identities[identityIndex] = identity;\r\n        this.walletConfig = walletConfig;\r\n        await this.updateConfig(gaiaConfig);\r\n    }\r\n    async updateConfigForReuseWarning({ gaiaConfig }) {\r\n        assertIsTruthy(this.walletConfig);\r\n        this.walletConfig.hideWarningForReusingIdentity = true;\r\n        await this.updateConfig(gaiaConfig);\r\n    }\r\n    getSigner() {\r\n        return new WalletSigner({ privateKey: this.stacksPrivateKey });\r\n    }\r\n}\r\nexport default Wallet;\r\n//# sourceMappingURL=index.js.map","references":["/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/bip39/types/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/node_modules/bitcoinjs-lib/types/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/@blockstack/stacks-transactions/lib/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/utils/index.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/identity.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/encryption/decrypt.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/mnemonic/index.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/address-derivation/index.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/storage/hub.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/utils/gaia.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/wallet/signer.ts"],"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/wallet/index.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,OAAO,CAAC;AACvC,OAAO,EAAE,KAAK,EAAkB,MAAM,eAAe,CAAC;AAGtD,OAAO,EACL,uBAAuB,EAEvB,YAAY,EACZ,cAAc,EACd,0BAA0B,GAC3B,MAAM,UAAU,CAAC;AAClB,OAAO,QAAQ,MAAM,aAAa,CAAC;AACnC,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAChD,OAAO,EACL,gBAAgB,EAChB,cAAc,EACd,uBAAuB,EACvB,cAAc,GACf,MAAM,YAAY,CAAC;AACpB,OAAO,EAEL,qCAAqC,EACrC,8BAA8B,EAC9B,wBAAwB,GACzB,MAAM,aAAa,CAAC;AACrB,OAAO,EAAE,qBAAqB,EAAE,MAAM,uBAAuB,CAAC;AAE9D,OAAO,EAAE,sBAAsB,EAAE,gBAAgB,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAC1F,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAC;AAExC,MAAM,YAAY,GAAG,EAAE,CAAC;AAqCxB,MAAM,OAAO,MAAM;IAajB,YAAY,EACV,KAAK,EACL,qBAAqB,EACrB,sBAAsB,EACtB,qBAAqB,EACrB,mBAAmB,EACnB,gBAAgB,EAChB,iBAAiB,EACjB,UAAU,EACV,gBAAgB,EAChB,gBAAgB,EAChB,YAAY,GACO;QACnB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;QACnD,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QACrD,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;QACnD,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;QACrE,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAED,MAAM,CAAC,eAAe,CAAC,WAAkC;QACvD,OAAO,KAAK,EAAE,QAAgB,EAAE,KAAc,EAAE,EAAE;YAChD,MAAM,EAAE,QAAQ,EAAE,uBAAuB,EAAE,GAAG,MAAM,qCAAqC,CACvF,QAAQ,EACR,WAAW,CACZ,CAAC;YACF,OAAO,IAAI,CAAC,aAAa,CAAC;gBACxB,qBAAqB,EAAE,uBAAuB;gBAC9C,QAAQ;gBACR,KAAK;aACN,CAAC,CAAC;QACL,CAAC,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAgB,EAAE,KAAc;QACpD,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC1D,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,QAAgB,EAAE,KAAc;QAC1D,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC1D,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,QAAgB,EAAE,UAAkB,EAAE,KAAc;QACvE,MAAM,QAAQ,GAAG,MAAM,8BAA8B,CAAC,UAAU,CAAC,CAAC;QAClE,MAAM,EAAE,oBAAoB,EAAE,GAAG,MAAM,wBAAwB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAEtF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,aAAa,CAAC;YACxC,qBAAqB,EAAE,oBAAoB;YAC3C,QAAQ;YACR,KAAK;SACN,CAAC,CAAC;QAEH,OAAO,MAAM,MAAM,CAAC,iBAAiB,CAAC,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAE,CAAC,CAAC;IACrF,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,EACzB,qBAAqB,EACrB,QAAQ,EACR,KAAK,EACL,oBAAoB,GAAG,CAAC,GAMzB;QACC,MAAM,oBAAoB,GAAG,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC,UAAU,CAAC;QAC9E,IAAI,CAAC,oBAAoB,EAAE;YACzB,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC,CAAC;SAC1E;QACD,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC9D,MAAM,EAAE,QAAQ,EAAE,kBAAkB,EAAE,GAAG,qBAAqB,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,CAAC;QAChF,MAAM,WAAW,GAAG,MAAM,uBAAuB,CAAC,QAAQ,EAAE,oBAAoB,CAAC,CAAC;QAElF,OAAO,IAAI,MAAM,CAAC;YAChB,GAAG,WAAW;YACd,KAAK;YACL,gBAAgB;YAChB,gBAAgB,EAAE,kBAAkB,CAAC,QAAQ,EAAE;YAC/C,qBAAqB;SACtB,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;OASG;IACH,KAAK,CAAC,iBAAiB,CAAC,EACtB,QAAQ,EACR,WAAW,GAIZ;QACC,MAAM,UAAU,GAAG,sBAAsB,CAAC;YACxC,OAAO,EAAE,WAAW;YACpB,UAAU,EAAE,IAAI,CAAC,gBAAgB;SAClC,CAAC,CAAC;QACH,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACnC,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,cAAc,EAAE,KAAK,EAAE,EAAE;gBACrF,IAAI,QAAQ,GAAoB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;gBACvD,IAAI,CAAC,QAAQ,EAAE;oBACb,QAAQ,GAAG,MAAM,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBAChD;gBACD,IAAI,cAAc,CAAC,QAAQ,EAAE;oBAC3B,QAAQ,CAAC,SAAS,GAAG,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;oBAC/C,QAAQ,CAAC,eAAe,GAAG,cAAc,CAAC,QAAQ,CAAC;iBACpD;gBACD,OAAO,QAAQ,CAAC;YAClB,CAAC,CAAC,CAAC;YACH,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;YACpD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;YAC7B,OAAO,IAAI,CAAC;SACb;QACD,MAAM,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QACnC,MAAM,aAAa,GAAG,MAAM,0BAA0B,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC;QACrE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QACxD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,KAAK,CAAC,iBAAiB,CAAC,QAAgB;QACtC,MAAM,eAAe,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,KAAK,CAAC,EAAE,QAAQ,CAAC,CAAC;QAChG,MAAM,IAAI,GAAG,MAAM,cAAc,CAAC,eAAe,CAAC,CAAC;QACnD,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACtC,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QACrC,MAAM,QAAQ,GAAG,MAAM,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QACrD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC9C,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,UAAkB;QACvC,OAAO,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC7D,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,UAAyB;QACzC,IAAI;YACF,MAAM,QAAQ,GAAG,MAAM,KAAK,CAC1B,GAAG,UAAU,CAAC,UAAU,GAAG,UAAU,CAAC,OAAO,qBAAqB,CACnE,CAAC;YACF,MAAM,SAAS,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;YACxC,MAAM,UAAU,GAAG,CAAC,MAAM,cAAc,CAAC,SAAS,EAAE;gBAClD,UAAU,EAAE,IAAI,CAAC,gBAAgB;aAClC,CAAC,CAAW,CAAC;YACd,MAAM,MAAM,GAAiB,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACpD,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;YAC3B,OAAO,MAAM,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAED,KAAK,CAAC,iBAAiB,CAAC,EACtB,UAAU,EACV,UAAU,GAIX;QACC,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;QACD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAClD,IAAI,MAAM,EAAE;YACV,OAAO,MAAM,CAAC;SACf;QACD,MAAM,SAAS,GAAiB;YAC9B,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;gBACpC,QAAQ,EAAE,CAAC,CAAC,eAAe;gBAC3B,OAAO,EAAE,CAAC,CAAC,OAAO;gBAClB,IAAI,EAAE,EAAE;aACT,CAAC,CAAC;SACJ,CAAC;QACF,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;QAC9B,IAAI,CAAC,UAAU,EAAE;YACf,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;SACrC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,UAAyB;QAC1C,MAAM,SAAS,GAAG,uBAAuB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACjE,MAAM,SAAS,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;QACzF,MAAM,eAAe,CAAC,oBAAoB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;IACrE,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,EACzB,aAAa,EACb,GAAG,EACH,UAAU,GAKX;QACC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC;QAC9B,cAAc,CAAe,YAAY,CAAC,CAAC;QAE3C,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,KAAK,EAAE,EAAE;YAC1C,MAAM,cAAc,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACtD,IAAI,cAAc,EAAE;gBAClB,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,IAAI,EAAE,CAAC;gBAChD,cAAc,CAAC,QAAQ,GAAG,QAAQ,CAAC,eAAe,CAAC;gBACnD,cAAc,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;gBAC1C,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,cAAc,CAAC;aACjD;iBAAM;gBACL,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,IAAI,CAAC;oBACjC,QAAQ,EAAE,QAAQ,CAAC,eAAe;oBAClC,OAAO,EAAE,QAAQ,CAAC,OAAO;oBACzB,IAAI,EAAE,EAAE;iBACT,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,YAAY,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;QACxD,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,IAAI,EAAE,CAAC;QACpC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;QAChC,YAAY,CAAC,UAAU,CAAC,aAAa,CAAC,GAAG,QAAQ,CAAC;QAClD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;IAED,KAAK,CAAC,2BAA2B,CAAC,EAAE,UAAU,EAAiC;QAC7E,cAAc,CAAe,IAAI,CAAC,YAAY,CAAC,CAAC;QAEhD,IAAI,CAAC,YAAY,CAAC,6BAA6B,GAAG,IAAI,CAAC;QAEvD,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;IAED,SAAS;QACP,OAAO,IAAI,YAAY,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC;IACjE,CAAC;CACF;AAED,eAAe,MAAM,CAAC\"}","dts":{"name":"/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/wallet/index.d.ts","writeByteOrderMark":false,"text":"import { bip32, BIP32Interface } from 'bitcoinjs-lib';\r\nimport { ChainID } from '@blockstack/stacks-transactions';\r\nimport { IdentityKeyPair } from '../utils';\r\nimport Identity from '../identity';\r\nimport { AllowedKeyEntropyBits } from '../mnemonic';\r\nimport { GaiaHubConfig } from 'blockstack/lib/storage/hub';\r\nimport { WalletSigner } from './signer';\r\nexport interface ConfigApp {\r\n    origin: string;\r\n    scopes: string[];\r\n    lastLoginAt: number;\r\n    appIcon: string;\r\n    name: string;\r\n}\r\ninterface ConfigIdentity {\r\n    username?: string;\r\n    address: string;\r\n    apps: {\r\n        [origin: string]: ConfigApp;\r\n    };\r\n}\r\nexport interface WalletConfig {\r\n    identities: ConfigIdentity[];\r\n    hideWarningForReusingIdentity?: boolean;\r\n}\r\nexport interface ConstructorOptions {\r\n    chain: ChainID;\r\n    identityPublicKeychain: string;\r\n    bitcoinPublicKeychain: string;\r\n    firstBitcoinAddress: string;\r\n    identityKeypairs: IdentityKeyPair[];\r\n    identityAddresses: string[];\r\n    encryptedBackupPhrase: string;\r\n    identities: Identity[];\r\n    configPrivateKey: string;\r\n    stacksPrivateKey: string;\r\n    walletConfig?: WalletConfig;\r\n}\r\nexport declare class Wallet {\r\n    chain: ChainID;\r\n    encryptedBackupPhrase: string;\r\n    bitcoinPublicKeychain: string;\r\n    firstBitcoinAddress: string;\r\n    identityKeypairs: IdentityKeyPair[];\r\n    identityAddresses: string[];\r\n    identityPublicKeychain: string;\r\n    identities: Identity[];\r\n    configPrivateKey: string;\r\n    stacksPrivateKey: string;\r\n    walletConfig?: WalletConfig;\r\n    constructor({ chain, encryptedBackupPhrase, identityPublicKeychain, bitcoinPublicKeychain, firstBitcoinAddress, identityKeypairs, identityAddresses, identities, configPrivateKey, stacksPrivateKey, walletConfig, }: ConstructorOptions);\r\n    static generateFactory(bitsEntropy: AllowedKeyEntropyBits): (password: string, chain: ChainID) => Promise<Wallet>;\r\n    static generate(password: string, chain: ChainID): Promise<Wallet>;\r\n    static generateStrong(password: string, chain: ChainID): Promise<Wallet>;\r\n    static restore(password: string, seedPhrase: string, chain: ChainID): Promise<Wallet>;\r\n    static createAccount({ encryptedBackupPhrase, rootNode, chain, identitiesToGenerate, }: {\r\n        encryptedBackupPhrase: string;\r\n        rootNode: BIP32Interface;\r\n        chain: ChainID;\r\n        identitiesToGenerate?: number;\r\n    }): Promise<Wallet>;\r\n    /**\r\n     * Restore all previously used identities. This is meant to be used when 'restoring' a wallet.\r\n     * First, it will check for a `walletConfig`. If present, then we use that to determine how\r\n     * many identities to generate, and auto-populate their username.\r\n     *\r\n     * If `walletConfig` is empty, then this is being restored from an authenticator that doesn't\r\n     * support `walletConfig`. In that case, we will recursively generate identities, and check for\r\n     * on-chain names.\r\n     *\r\n     */\r\n    restoreIdentities({ rootNode, gaiaReadURL, }: {\r\n        rootNode: bip32.BIP32Interface;\r\n        gaiaReadURL: string;\r\n    }): Promise<this>;\r\n    createNewIdentity(password: string): Promise<Identity>;\r\n    createGaiaConfig(gaiaHubUrl: string): Promise<GaiaHubConfig>;\r\n    fetchConfig(gaiaConfig: GaiaHubConfig): Promise<WalletConfig | null>;\r\n    getOrCreateConfig({ gaiaConfig, skipUpload, }: {\r\n        gaiaConfig: GaiaHubConfig;\r\n        skipUpload?: boolean;\r\n    }): Promise<WalletConfig>;\r\n    updateConfig(gaiaConfig: GaiaHubConfig): Promise<void>;\r\n    updateConfigWithAuth({ identityIndex, app, gaiaConfig, }: {\r\n        identityIndex: number;\r\n        app: ConfigApp;\r\n        gaiaConfig: GaiaHubConfig;\r\n    }): Promise<void>;\r\n    updateConfigForReuseWarning({ gaiaConfig }: {\r\n        gaiaConfig: GaiaHubConfig;\r\n    }): Promise<void>;\r\n    getSigner(): WalletSigner;\r\n}\r\nexport default Wallet;\r\n"}}
