{"code":"import IdentityAddressOwnerNode from '../nodes/identity-address-owner-node';\r\nimport { createSha2Hash } from 'blockstack/lib/encryption/sha2Hash';\r\nimport { publicKeyToAddress } from 'blockstack/lib/keys';\r\nimport { parseZoneFile } from 'zone-file';\r\nimport Identity from '../identity';\r\nimport { AssertionError } from 'assert';\r\nimport { Subdomains, registrars } from '../profiles';\r\nconst IDENTITY_KEYCHAIN = 888;\r\nconst BLOCKSTACK_ON_BITCOIN = 0;\r\nexport function getIdentityPrivateKeychain(rootNode) {\r\n    return rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\r\n}\r\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\r\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS';\r\nexport function getBitcoinPrivateKeychain(rootNode) {\r\n    const BIP_44_PURPOSE = 44;\r\n    const BITCOIN_COIN_TYPE = 0;\r\n    const ACCOUNT_INDEX = 0;\r\n    return rootNode\r\n        .deriveHardened(BIP_44_PURPOSE)\r\n        .deriveHardened(BITCOIN_COIN_TYPE)\r\n        .deriveHardened(ACCOUNT_INDEX);\r\n}\r\nexport function getBitcoinAddressNode(bitcoinKeychain, addressIndex = 0, chainType = EXTERNAL_ADDRESS) {\r\n    let chain = null;\r\n    if (chainType === EXTERNAL_ADDRESS) {\r\n        chain = 0;\r\n    }\r\n    else if (chainType === CHANGE_ADDRESS) {\r\n        chain = 1;\r\n    }\r\n    else {\r\n        throw new Error('Invalid chain type');\r\n    }\r\n    return bitcoinKeychain.derive(chain).derive(addressIndex);\r\n}\r\nexport async function getIdentityOwnerAddressNode(identityPrivateKeychain, identityIndex = 0) {\r\n    if (identityPrivateKeychain.isNeutered()) {\r\n        throw new Error('You need the private key to generate identity addresses');\r\n    }\r\n    const publicKeyHex = Buffer.from(identityPrivateKeychain.publicKey.toString('hex'));\r\n    const sha2Hash = await createSha2Hash();\r\n    const saltData = await sha2Hash.digest(publicKeyHex, 'sha256');\r\n    const salt = saltData.toString('hex');\r\n    return new IdentityAddressOwnerNode(identityPrivateKeychain.deriveHardened(identityIndex), salt);\r\n}\r\nexport function getAddress(node) {\r\n    return publicKeyToAddress(node.publicKey);\r\n}\r\nexport function deriveIdentityKeyPair(identityOwnerAddressNode) {\r\n    const address = identityOwnerAddressNode.getAddress();\r\n    const identityKey = identityOwnerAddressNode.getIdentityKey();\r\n    const identityKeyID = identityOwnerAddressNode.getIdentityKeyID();\r\n    const appsNode = identityOwnerAddressNode.getAppsNode();\r\n    const stxNode = identityOwnerAddressNode.getSTXNode();\r\n    const keyPair = {\r\n        key: identityKey,\r\n        keyID: identityKeyID,\r\n        address,\r\n        appsNodeKey: appsNode.toBase58(),\r\n        stxNodeKey: stxNode.toBase58(),\r\n        salt: identityOwnerAddressNode.getSalt(),\r\n    };\r\n    return keyPair;\r\n}\r\nexport async function getBlockchainIdentities(rootNode, identitiesToGenerate) {\r\n    const identityPrivateKeychainNode = getIdentityPrivateKeychain(rootNode);\r\n    const bitcoinPrivateKeychainNode = getBitcoinPrivateKeychain(rootNode);\r\n    const identityPublicKeychainNode = identityPrivateKeychainNode.neutered();\r\n    const identityPublicKeychain = identityPublicKeychainNode.toBase58();\r\n    const bitcoinPublicKeychainNode = bitcoinPrivateKeychainNode.neutered();\r\n    const bitcoinPublicKeychain = bitcoinPublicKeychainNode.toBase58();\r\n    const firstBitcoinAddress = getAddress(getBitcoinAddressNode(bitcoinPublicKeychainNode));\r\n    const identityAddresses = [];\r\n    const identityKeypairs = [];\r\n    const identities = [];\r\n    // We pre-generate a number of identity addresses so that we\r\n    // don't have to prompt the user for the password on each new profile\r\n    for (let addressIndex = 0; addressIndex < identitiesToGenerate; addressIndex++) {\r\n        const identity = await makeIdentity(rootNode, addressIndex);\r\n        identities.push(identity);\r\n        identityKeypairs.push(identity.keyPair);\r\n        identityAddresses.push(identity.address);\r\n    }\r\n    return {\r\n        identityPublicKeychain,\r\n        bitcoinPublicKeychain,\r\n        firstBitcoinAddress,\r\n        identityAddresses,\r\n        identityKeypairs,\r\n        identities,\r\n    };\r\n}\r\nexport const makeIdentity = async (rootNode, index) => {\r\n    const identityPrivateKeychainNode = getIdentityPrivateKeychain(rootNode);\r\n    const identityOwnerAddressNode = await getIdentityOwnerAddressNode(identityPrivateKeychainNode, index);\r\n    const identityKeyPair = deriveIdentityKeyPair(identityOwnerAddressNode);\r\n    const identity = new Identity({\r\n        keyPair: identityKeyPair,\r\n        address: identityKeyPair.address,\r\n        usernames: [],\r\n    });\r\n    return identity;\r\n};\r\nexport function assertIsTruthy(val) {\r\n    if (!val) {\r\n        throw new AssertionError({ expected: true, actual: val });\r\n    }\r\n}\r\nexport var IdentityNameValidityError;\r\n(function (IdentityNameValidityError) {\r\n    IdentityNameValidityError[\"MINIMUM_LENGTH\"] = \"error_minimum_length\";\r\n    IdentityNameValidityError[\"MAXIMUM_LENGTH\"] = \"error_maximum_length\";\r\n    IdentityNameValidityError[\"ILLEGAL_CHARACTER\"] = \"error_illegal_character\";\r\n    IdentityNameValidityError[\"UNAVAILABLE\"] = \"error_name_unavailable\";\r\n})(IdentityNameValidityError || (IdentityNameValidityError = {}));\r\nconst containsLegalCharacters = (name) => /^[a-z0-9_]+$/.test(name);\r\nexport const validateSubdomainFormat = (identityName) => {\r\n    const nameLength = identityName.length;\r\n    if (nameLength < 8) {\r\n        return IdentityNameValidityError.MINIMUM_LENGTH;\r\n    }\r\n    if (nameLength > 37) {\r\n        return IdentityNameValidityError.MAXIMUM_LENGTH;\r\n    }\r\n    if (!containsLegalCharacters(identityName)) {\r\n        return IdentityNameValidityError.ILLEGAL_CHARACTER;\r\n    }\r\n    return null;\r\n};\r\nexport const validateSubdomainAvailability = async (name, subdomain = Subdomains.BLOCKSTACK) => {\r\n    const url = `${registrars[subdomain].apiUrl}/${name.toLowerCase()}.${subdomain}`;\r\n    const resp = await fetch(url);\r\n    const data = await resp.json();\r\n    return data;\r\n};\r\n/**\r\n * Restore identities by recursively making a new identity, and checking if it has a username.\r\n *\r\n * As soon as a username is not found for an identity, the recursion stops.\r\n */\r\nexport const recursiveRestoreIdentities = async ({ rootNode, index = 1, identities = [], }) => {\r\n    const identity = await makeIdentity(rootNode, index);\r\n    await identity.refresh();\r\n    if (identity.defaultUsername) {\r\n        identities.push(identity);\r\n        return recursiveRestoreIdentities({ rootNode, index: index + 1, identities });\r\n    }\r\n    return identities;\r\n};\r\n/**\r\n * Validate the format and availability of a subdomain. Will return an error of enum\r\n * IdentityNameValidityError if an error is present. If no errors are found, will return null.\r\n * @param name the subdomain to be registered\r\n * @param subdomain a valid Subdomains enum\r\n */\r\nexport const validateSubdomain = async (name, subdomain = Subdomains.BLOCKSTACK) => {\r\n    const error = validateSubdomainFormat(name);\r\n    if (error) {\r\n        return error;\r\n    }\r\n    try {\r\n        const data = await validateSubdomainAvailability(name, subdomain);\r\n        if (data.status !== 'available') {\r\n            return IdentityNameValidityError.UNAVAILABLE;\r\n        }\r\n    }\r\n    catch (error) {\r\n        return IdentityNameValidityError.UNAVAILABLE;\r\n    }\r\n    return null;\r\n};\r\nexport const getProfileURLFromZoneFile = async (name) => {\r\n    const url = `https://core.blockstack.org/v1/names/${name}`;\r\n    const res = await fetch(url);\r\n    if (res.ok) {\r\n        const nameInfo = await res.json();\r\n        const zone = parseZoneFile(nameInfo.zonefile);\r\n        return zone.uri[0].target;\r\n    }\r\n    return;\r\n};\r\n//# sourceMappingURL=index.js.map","references":["/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/node_modules/bitcoinjs-lib/types/index.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/nodes/identity-address-owner-node.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/encryption/sha2Hash.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/blockstack/lib/keys.d.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/zone-file/lib/index.js","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/identity.ts","/Users/Yukan/Desktop/work/blockstack/stacks.js/node_modules/assert/assert.js","/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/src/profiles.ts"],"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/utils/index.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/Yukan/Desktop/work/blockstack/stacks.js/packages/keychain/utils/index.d.ts","writeByteOrderMark":false,"text":"import { BIP32Interface } from 'bitcoinjs-lib';\r\nimport IdentityAddressOwnerNode from '../nodes/identity-address-owner-node';\r\nimport Identity from '../identity';\r\nimport { Subdomains } from '../profiles';\r\nexport declare function getIdentityPrivateKeychain(rootNode: BIP32Interface): BIP32Interface;\r\nexport declare function getBitcoinPrivateKeychain(rootNode: BIP32Interface): BIP32Interface;\r\nexport declare function getBitcoinAddressNode(bitcoinKeychain: BIP32Interface, addressIndex?: number, chainType?: string): BIP32Interface;\r\nexport declare function getIdentityOwnerAddressNode(identityPrivateKeychain: BIP32Interface, identityIndex?: number): Promise<IdentityAddressOwnerNode>;\r\nexport declare function getAddress(node: BIP32Interface): string;\r\nexport interface IdentityKeyPair {\r\n    key: string;\r\n    keyID: string;\r\n    address: string;\r\n    appsNodeKey: string;\r\n    stxNodeKey: string;\r\n    salt: string;\r\n}\r\nexport declare function deriveIdentityKeyPair(identityOwnerAddressNode: IdentityAddressOwnerNode): IdentityKeyPair;\r\nexport declare function getBlockchainIdentities(rootNode: BIP32Interface, identitiesToGenerate: number): Promise<{\r\n    identityPublicKeychain: string;\r\n    bitcoinPublicKeychain: string;\r\n    firstBitcoinAddress: string;\r\n    identityAddresses: string[];\r\n    identityKeypairs: IdentityKeyPair[];\r\n    identities: Identity[];\r\n}>;\r\nexport declare const makeIdentity: (rootNode: BIP32Interface, index: number) => Promise<Identity>;\r\nexport declare function assertIsTruthy<T>(val: any): asserts val is NonNullable<T>;\r\nexport declare enum IdentityNameValidityError {\r\n    MINIMUM_LENGTH = \"error_minimum_length\",\r\n    MAXIMUM_LENGTH = \"error_maximum_length\",\r\n    ILLEGAL_CHARACTER = \"error_illegal_character\",\r\n    UNAVAILABLE = \"error_name_unavailable\"\r\n}\r\nexport declare const validateSubdomainFormat: (identityName: string) => IdentityNameValidityError | null;\r\nexport declare const validateSubdomainAvailability: (name: string, subdomain?: Subdomains) => Promise<any>;\r\ninterface RecursiveMakeIdentitiesOptions {\r\n    rootNode: BIP32Interface;\r\n    index?: number;\r\n    identities?: Identity[];\r\n}\r\n/**\r\n * Restore identities by recursively making a new identity, and checking if it has a username.\r\n *\r\n * As soon as a username is not found for an identity, the recursion stops.\r\n */\r\nexport declare const recursiveRestoreIdentities: ({ rootNode, index, identities, }: RecursiveMakeIdentitiesOptions) => Promise<Identity[]>;\r\n/**\r\n * Validate the format and availability of a subdomain. Will return an error of enum\r\n * IdentityNameValidityError if an error is present. If no errors are found, will return null.\r\n * @param name the subdomain to be registered\r\n * @param subdomain a valid Subdomains enum\r\n */\r\nexport declare const validateSubdomain: (name: string, subdomain?: Subdomains) => Promise<IdentityNameValidityError | null>;\r\nexport declare const getProfileURLFromZoneFile: (name: string) => Promise<string | undefined>;\r\nexport {};\r\n"}}
