// @ts-ignore: Could not find a declaration file for module
import { TokenSigner, SECP256K1Client } from 'jsontokens'

import queryString from 'query-string'
import { AppConfig } from './appConfig'
import { SessionOptions } from './sessionData'
import {
  LocalStorageStore,
  SessionDataStore,
  InstanceDataStore
} from './sessionStore'
import {
  detectProtocolLaunch,
  UserData
} from './authApp'
import {
  generateTransitKey,
  decryptPrivateKey,
  VERSION
} from './authMessages'
import {
  PutFileOptions,
  GetFileOptions,
  getFileSignedUnencrypted,
  getFileContents,
  handleSignedEncryptedContents,
  SIGNATURE_FILE_SUFFIX,
  getUserAppFileUrl
} from '../storage'
import {
  nextHour, isLaterVersion, hexStringToECPair, makeUUID4
} from '../utils'
import {
  MissingParameterError,
  InvalidStateError,
  LoginFailedError
} from '../errors'
import { Logger } from '../logger'
import { decryptECIES, encryptECIES, signECDSA } from '../encryption/ec'
import { getPublicKeyFromPrivate, publicKeyToAddress } from '../keys'
import { 
  getOrSetLocalGaiaHubConnection, uploadToGaiaHub, 
  setLocalGaiaHubConnection, GaiaHubConfig, getFullReadUrl 
} from '../storage/hub'
import { 
  DEFAULT_BLOCKSTACK_HOST, NAME_LOOKUP_PATH, 
  BLOCKSTACK_DEFAULT_GAIA_HUB_URL 
} from './authConstants'
import { config } from '../config'
import { 
  decodeToken, verifyAuthResponse, 
  getAddressFromDID, extractProfile, makeDIDFromAddress 
} from '../index'


/**
 * Represents an instance of a signed in user for a particular app.
 *
 * A signed in user has access to two major pieces of information
 * about the user, the user's private key for that app and the location
 * of the user's gaia storage bucket for the app.
 *
 * A user can be signed in either directly through the interactive
 * sign in process or by directly providing the app private key.
 * @type {UserSession}
 */
export class UserSession {
  appConfig: AppConfig

  store: SessionDataStore

  constructor(options?: {
    appConfig?: AppConfig,
    sessionStore?: SessionDataStore,
    sessionOptions?: SessionOptions }) {
    let runningInBrowser = true

    if (typeof window === 'undefined') {
      Logger.debug('UserSession: not running in browser')
      runningInBrowser = false
    }

    if (options && options.appConfig) {
      this.appConfig = options.appConfig
    } else if (runningInBrowser) {
      this.appConfig = new AppConfig()
    } else {
      throw new MissingParameterError('You need to specify options.appConfig')
    }

    if (options && options.sessionStore) {
      this.store = options.sessionStore
    } else if (runningInBrowser) {
      if (options) {
        this.store = new LocalStorageStore(options.sessionOptions)
      } else {
        this.store = new LocalStorageStore()
      }
    } else if (options) {
      this.store = new InstanceDataStore(options.sessionOptions)
    } else {
      this.store = new InstanceDataStore()
    }
  }

  /* AUTHENTICATION */

  /**
   * Generates an authentication request and redirects the user to the Blockstack
   * browser to approve the sign in request.
   *
   * Please note that this requires that the web browser properly handles the
   * `blockstack:` URL protocol handler.
   *
   * Most applications should use this
   * method for sign in unless they require more fine grained control over how the
   * authentication request is generated. If your app falls into this category,
   * use `generateAndStoreTransitKey`, `makeAuthRequest`,
   * and `redirectToSignInWithAuthRequest` to build your own sign in process.
   *
   * @return {void}
   */
  redirectToSignIn() {
    const transitKey = this.generateAndStoreTransitKey()
    const authRequest = this.makeAuthRequest(transitKey)
    return this.redirectToSignInWithAuthRequest(authRequest)
  }

  /**
   * Redirects the user to the Blockstack browser to approve the sign in request
   * given.
   *
   * The user is redirected to the authenticator URL specified in the `AppConfig`
   * if the `blockstack:` protocol handler is not detected.
   * Please note that the protocol handler detection
   * does not work on all browsers.
   * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
   * @return {void}
   */
  redirectToSignInWithAuthRequest(authRequest: string) {
    let httpsURI = `${DEFAULT_BLOCKSTACK_HOST}?authRequest=${authRequest}`

    if (this.appConfig
        && this.appConfig.authenticatorURL) {
      httpsURI = `${this.appConfig.authenticatorURL}?authRequest=${authRequest}`
    }
  
    // If they're on a mobile OS, always redirect them to HTTPS site
    if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
      Logger.info('detected mobile OS, sending to https')
      window.location.href = httpsURI
      return
    }
  
    function successCallback() {
      Logger.info('protocol handler detected')
      // The detection function should open the link for us
    }
  
    function failCallback() {
      Logger.warn('protocol handler not detected')
      window.location.href = httpsURI
    }
  
    detectProtocolLaunch(authRequest, successCallback, failCallback)
  }

  /**
   * Generates an authentication request that can be sent to the Blockstack
   * browser for the user to approve sign in. This authentication request can
   * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
   * method.
   *
   * *Note: This method should only be used if you want to roll your own authentication
   * flow. Typically you'd use `redirectToSignIn` which takes care of this
   * under the hood.*
   * @param {string} transitKey - hex-encoded transit key
   * @param {Number} expiresAt - the time at which this request is no longer valid
   * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.
   * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported
   * by special authenticators.
   * @return {String} the authentication request
   * @private
   */
  makeAuthRequest(transitKey: string,
                  expiresAt: number = nextHour().getTime(),
                  extraParams: any = {}): string {
    const appConfig = this.appConfig

    if (!appConfig) {
      throw new InvalidStateError('Missing AppConfig')
    }
    const redirectURI = appConfig.redirectURI()
    const manifestURI = appConfig.manifestURI()
    const scopes = appConfig.scopes
    const appDomain = appConfig.appDomain

    /* Create the payload */
    const payload = Object.assign({}, extraParams, {
      jti: makeUUID4(),
      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds
      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds
      iss: null,
      public_keys: [],
      domain_name: appDomain,
      manifest_uri: manifestURI,
      redirect_uri: redirectURI,
      version: VERSION,
      do_not_include_profile: true,
      supports_hub_url: true,
      scopes
    })

    Logger.info(`blockstack.js: generating v${VERSION} auth request`)

    /* Convert the private key to a public key to an issuer */
    const publicKey = SECP256K1Client.derivePublicKey(transitKey)
    payload.public_keys = [publicKey]
    const address = publicKeyToAddress(publicKey)
    payload.iss = makeDIDFromAddress(address)

    /* Sign and return the token */
    const tokenSigner = new TokenSigner('ES256k', transitKey)
    const token = tokenSigner.sign(payload)

    return token
  }

  /**
   * Generates a ECDSA keypair to
   * use as the ephemeral app transit private key
   * and store in the session
   * @return {String} the hex encoded private key
   *
   */
  generateAndStoreTransitKey(): string {
    const sessionData = this.store.getSessionData()
    const transitKey = generateTransitKey()
    sessionData.transitKey = transitKey
    this.store.setSessionData(sessionData)
    return transitKey
  }

  /**
   * Retrieve the authentication token from the URL query
   * @return {String} the authentication token if it exists otherwise `null`
   */
  getAuthResponseToken(): string {
    const queryDict = queryString.parse(location.search)
    return queryDict.authResponse ? <string>queryDict.authResponse : ''
  }

  /**
   * Check if there is a authentication request that hasn't been handled.
   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
   */
  isSignInPending() {
    return !!this.getAuthResponseToken()
  }

  /**
   * Check if a user is currently signed in.
   * @return {Boolean} `true` if the user is signed in, `false` if not.
   */
  isUserSignedIn() {
    return !!this.store.getSessionData().userData
  }

  /**
   * Try to process any pending sign in request by returning a `Promise` that resolves
   * to the user data object if the sign in succeeds.
   *
   * @param {String} authResponseToken - the signed authentication response token
   * @return {Promise} that resolves to the user data object if successful and rejects
   * if handling the sign in request fails or there was no pending sign in request.
   */
  handlePendingSignIn(authResponseToken: string = this.getAuthResponseToken()) {
    const transitKey = this.store.getSessionData().transitKey
    const coreNodeSessionValue = this.store.getSessionData().coreNode
    let nameLookupURL = null
  
    if (!coreNodeSessionValue) {
      const tokenPayload = decodeToken(authResponseToken).payload
      if (isLaterVersion(tokenPayload.version, '1.3.0')
         && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {
        // override globally
        Logger.info(`Overriding ${config.network.blockstackAPIUrl} `
          + `with ${tokenPayload.blockstackAPIUrl}`)
        config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl
      }
      nameLookupURL = `${config.network.blockstackAPIUrl}${NAME_LOOKUP_PATH}`
    } else {
      nameLookupURL = `${coreNodeSessionValue}${NAME_LOOKUP_PATH}`
    }
    return verifyAuthResponse(authResponseToken, nameLookupURL)
      .then((isValid) => {
        if (!isValid) {
          throw new LoginFailedError('Invalid authentication response.')
        }
        const tokenPayload = decodeToken(authResponseToken).payload
        // TODO: real version handling
        let appPrivateKey = tokenPayload.private_key
        let coreSessionToken = tokenPayload.core_token
        if (isLaterVersion(tokenPayload.version, '1.1.0')) {
          if (transitKey !== undefined && transitKey != null) {
            if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {
              try {
                appPrivateKey = decryptPrivateKey(transitKey, tokenPayload.private_key)
              } catch (e) {
                Logger.warn('Failed decryption of appPrivateKey, will try to use as given')
                try {
                  hexStringToECPair(tokenPayload.private_key)
                } catch (ecPairError) {
                  throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means'
                                           + ' that the transit key has changed during login.')
                }
              }
            }
            if (coreSessionToken !== undefined && coreSessionToken !== null) {
              try {
                coreSessionToken = decryptPrivateKey(transitKey, coreSessionToken)
              } catch (e) {
                Logger.info('Failed decryption of coreSessionToken, will try to use as given')
              }
            }
          } else {
            throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit'
                                     + ' key, and none found.')
          }
        }
        let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL
        let gaiaAssociationToken
        if (isLaterVersion(tokenPayload.version, '1.2.0')
          && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {
          hubUrl = tokenPayload.hubUrl
        }
        if (isLaterVersion(tokenPayload.version, '1.3.0')
          && tokenPayload.associationToken !== null 
          && tokenPayload.associationToken !== undefined) {
          gaiaAssociationToken = tokenPayload.associationToken
        }
  
        const userData: UserData = {
          username: tokenPayload.username,
          profile: tokenPayload.profile,
          email: tokenPayload.email,
          decentralizedID: tokenPayload.iss,
          identityAddress: getAddressFromDID(tokenPayload.iss),
          appPrivateKey,
          coreSessionToken,
          authResponseToken,
          hubUrl,
          gaiaAssociationToken
        }
        const profileURL = tokenPayload.profile_url
        if ((userData.profile === null
           || userData.profile === undefined)
          && profileURL !== undefined && profileURL !== null) {
          return fetch(profileURL)
            .then((response) => {
              if (!response.ok) { // return blank profile if we fail to fetch
                userData.profile = {
                  '@type': 'Person',
                  '@context': 'http://schema.org'
                }
                const sessionData = this.store.getSessionData()
                sessionData.userData = userData
                this.store.setSessionData(sessionData)
                return userData
              } else {
                return response.text()
                  .then(responseText => JSON.parse(responseText))
                  .then(wrappedProfile => extractProfile(wrappedProfile[0].token))
                  .then((profile) => {
                    const sessionData = this.store.getSessionData()
                    userData.profile = profile
                    sessionData.userData = userData
                    this.store.setSessionData(sessionData)
                    return userData
                  })
              }
            })
        } else {
          const sessionData = this.store.getSessionData()
          userData.profile = tokenPayload.profile
          sessionData.userData = userData
          this.store.setSessionData(sessionData)
          return userData
        }
      })
  }

  /**
   * Retrieves the user data object. The user's profile is stored in the key `profile`.
   * @return {Object} User data object.
   */
  loadUserData() {
    const userData = this.store.getSessionData().userData
    if (!userData) {
      throw new InvalidStateError('No user data found. Did the user sign in?')
    }
    return userData
  }


  /**
   * Sign the user out
   * @return {void}
   */
  signUserOut() {
    this.store.deleteSessionData()
  }

  //
  //
  // /* PROFILES */
  // extractProfile
  // wrapProfileToken
  // signProfileToken
  // verifyProfileToken
  // validateProofs
  // lookupProfile


  /* STORAGE */

  /**
   * Encrypts the data provided with the app public key.
   * @param {String|Buffer} content - data to encrypt
   * @param {Object} [options=null] - options object
   * @param {String} options.publicKey - the hex string of the ECDSA public
   * key to use for encryption. If not provided, will use user's appPrivateKey.
   * @return {String} Stringified ciphertext object
   */
  encryptContent(content: string | Buffer,
                 options?: {publicKey?: string}) {
    const defaults: { publicKey: string | null } = { publicKey: null }
    const opt = Object.assign({}, defaults, options)
    if (!opt.publicKey) {
      const userData = this.loadUserData()
      const privateKey = userData.appPrivateKey
      opt.publicKey = getPublicKeyFromPrivate(privateKey)
    }

    const cipherObject = encryptECIES(opt.publicKey, content)
    return JSON.stringify(cipherObject)
  }

  /**
   * Decrypts data encrypted with `encryptContent` with the
   * transit private key.
   * @param {String|Buffer} content - encrypted content.
   * @param {Object} [options=null] - options object
   * @param {String} options.privateKey - the hex string of the ECDSA private
   * key to use for decryption. If not provided, will use user's appPrivateKey.
   * @return {String|Buffer} decrypted content.
   */
  decryptContent(content: string, options?: { privateKey?: string }) {
    const defaults: {privateKey?: string | null } = { privateKey: null }
    const opt = Object.assign({}, defaults, options)
    let privateKey = opt.privateKey
    if (!privateKey) {
      privateKey = this.loadUserData().appPrivateKey
    }
  
    try {
      const cipherObject = JSON.parse(content)
      return decryptECIES(privateKey, cipherObject)
    } catch (err) {
      if (err instanceof SyntaxError) {
        throw new Error('Failed to parse encrypted content JSON. The content may not '
                        + 'be encrypted. If using getFile, try passing { decrypt: false }.')
      } else {
        throw err
      }
    }
  }

  /**
   * Stores the data provided in the app's data store to to the file specified.
   * @param {String} path - the path to store the data in
   * @param {String|Buffer} content - the data to store in the file
   * @param {Object} [options=null] - options object
   * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app private key
   *                                                  or the provided public key
   * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with
   *                                         the app private key
   * @return {Promise} that resolves if the operation succeed and rejects
   * if it failed
   */
  putFile(path: string, content: string | Buffer, options?: PutFileOptions) {
    const defaults = {
      encrypt: true,
      sign: false,
      contentType: ''
    }
  
    const opt = Object.assign({}, defaults, options)
  
    let { contentType } = opt
    if (!contentType) {
      contentType = (typeof (content) === 'string') ? 'text/plain; charset=utf-8' : 'application/octet-stream'
    }
  
    // First, let's figure out if we need to get public/private keys,
    //  or if they were passed in
  
    let privateKey = ''
    let publicKey = ''
    if (opt.sign) {
      if (typeof (opt.sign) === 'string') {
        privateKey = opt.sign
      } else {
        privateKey = this.loadUserData().appPrivateKey
      }
    }
    if (opt.encrypt) {
      if (typeof (opt.encrypt) === 'string') {
        publicKey = opt.encrypt
      } else {
        if (!privateKey) {
          privateKey = this.loadUserData().appPrivateKey
        }
        publicKey = getPublicKeyFromPrivate(privateKey)
      }
    }
  
    // In the case of signing, but *not* encrypting,
    //   we perform two uploads. So the control-flow
    //   here will return there.
    if (!opt.encrypt && opt.sign) {
      const signatureObject = signECDSA(privateKey, content)
      const signatureContent = JSON.stringify(signatureObject)
      return getOrSetLocalGaiaHubConnection(this)
        .then(gaiaHubConfig => new Promise<string[]>((resolve, reject) => Promise.all([
          uploadToGaiaHub(path, content, gaiaHubConfig, contentType),
          uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`,
                          signatureContent, gaiaHubConfig, 'application/json')
        ])
          .then(files => resolve(files))
          .catch(() => {
            setLocalGaiaHubConnection(this)
              .then(freshHubConfig => Promise.all([
                uploadToGaiaHub(path, content, freshHubConfig, contentType),
                uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`,
                                signatureContent, freshHubConfig, 'application/json')
              ])
                .then(files => resolve(files)).catch(reject))
          })))
        .then(fileUrls => fileUrls[0])
    }
  
    // In all other cases, we only need one upload.
    if (opt.encrypt && !opt.sign) {
      content = this.encryptContent(content, { publicKey })
      contentType = 'application/json'
    } else if (opt.encrypt && opt.sign) {
      const cipherText = this.encryptContent(content, { publicKey })
      const signatureObject = signECDSA(privateKey, cipherText)
      const signedCipherObject = {
        signature: signatureObject.signature,
        publicKey: signatureObject.publicKey,
        cipherText
      }
      content = JSON.stringify(signedCipherObject)
      contentType = 'application/json'
    }
    return getOrSetLocalGaiaHubConnection(this)
      .then(gaiaHubConfig => new Promise<string>((resolve, reject) => {
        uploadToGaiaHub(path, content, gaiaHubConfig, contentType)
          .then(resolve)
          .catch(() => {
            setLocalGaiaHubConnection(this)
              .then(freshHubConfig => uploadToGaiaHub(path, content, freshHubConfig, contentType)
                .then(file => resolve(file)).catch(reject))
          })
      }))
  }

  /**
   * Retrieves the specified file from the app's data store.
   * @param {String} path - the path to the file to read
   * @param {Object} [options=null] - options object
   * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key
   * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
   * @param {Boolean} options.verify - Whether the content should be verified, only to be used
   * when `putFile` was set to `sign = true`
   * @param {String} options.app - the app to lookup for multi-player storage -
   * defaults to current origin
   * @param {String} [options.zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, this will use the
   * blockstack.js's getNameInfo function instead.
   * @returns {Promise} that resolves to the raw data in the file
   * or rejects with an error
   */
  getFile(path: string, options?: GetFileOptions) {
    const appConfig = this.appConfig
    if (!appConfig) {
      throw new InvalidStateError('Missing AppConfig')
    }
    const defaults: GetFileOptions = {
      decrypt: true,
      verify: false,
      username: null,
      app: appConfig.appDomain,
      zoneFileLookupURL: null
    }
  
    const opt = Object.assign({}, defaults, options)
  
    // in the case of signature verification, but no
    //  encryption expected, need to fetch _two_ files.
    if (opt.verify && !opt.decrypt) {
      return getFileSignedUnencrypted(this, path, opt)
    }
  
    return getFileContents(this, path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt)
      .then<string|ArrayBuffer|Buffer>((storedContents) => {
        if (storedContents === null) {
          return storedContents
        } else if (opt.decrypt && !opt.verify) {
          if (typeof storedContents !== 'string') {
            throw new Error('Expected to get back a string for the cipherText')
          }
          return this.decryptContent(storedContents)
        } else if (opt.decrypt && opt.verify) {
          if (typeof storedContents !== 'string') {
            throw new Error('Expected to get back a string for the cipherText')
          }
          return handleSignedEncryptedContents(this, path, storedContents,
                                               opt.app, opt.username, opt.zoneFileLookupURL)
        } else if (!opt.verify && !opt.decrypt) {
          return storedContents
        } else {
          throw new Error('Should be unreachable.')
        }
      })
  }

  /**
   * Loop over the list of files in a Gaia hub, and run a callback on each entry.
   * Not meant to be called by external clients.
   * @param {GaiaHubConfig} hubConfig - the Gaia hub config
   * @param {String | null} page - the page ID
   * @param {number} callCount - the loop count
   * @param {number} fileCount - the number of files listed so far
   * @param {function} callback - the callback to invoke on each file.  If it returns a falsey
   *  value, then the loop stops.  If it returns a truthy value, the loop continues.
   * @returns {Promise} that resolves to the number of files listed.
   * @private
   */
  listFilesLoop(
    hubConfig: GaiaHubConfig,
    page: string | null,
    callCount: number,
    fileCount: number,
    callback: (name: string) => boolean): Promise<number> {
    if (callCount > 65536) {
      // this is ridiculously huge, and probably indicates
      // a faulty Gaia hub anyway (e.g. on that serves endless data)
      throw new Error('Too many entries to list')
    }

    let httpStatus
    const pageRequest = JSON.stringify({ page })

    const fetchOptions = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': `${pageRequest.length}`,
        Authorization: `bearer ${hubConfig.token}`
      },
      body: pageRequest
    }

    return fetch(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions)
      .then((response) => {
        httpStatus = response.status
        if (httpStatus >= 400) {
          throw new Error(`listFiles failed with HTTP status ${httpStatus}`)
        }
        return response.text()
      })
      .then(responseText => JSON.parse(responseText))
      .then((responseJSON) => {
        const entries = responseJSON.entries
        const nextPage = responseJSON.page
        if (entries === null || entries === undefined) {
          // indicates a misbehaving Gaia hub or a misbehaving driver
          // (i.e. the data is malformed)
          throw new Error('Bad listFiles response: no entries')
        }
        for (let i = 0; i < entries.length; i++) {
          const rc = callback(entries[i])
          if (!rc) {
            // callback indicates that we're done
            return Promise.resolve(fileCount + i)
          }
        }
        if (nextPage && entries.length > 0) {
          // keep going -- have more entries
          return this.listFilesLoop(
            hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback
          )
        } else {
          // no more entries -- end of data
          return Promise.resolve(fileCount + entries.length)
        }
      })
  }

  /**
   * Get the URL for reading a file from an app's data store.
   * @param {String} path - the path to the file to read
   * @param {Object} [options=null] - options object
   * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
   * @param {String} options.app - the app to lookup for multi-player storage -
   * defaults to current origin
   * @param {String} [options.zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, this will use the
   * blockstack.js's getNameInfo function instead.
   * @returns {Promise<string>} that resolves to the URL or rejects with an error
   */
  getFileUrl(path: string, options?: {
    username?: string,
    app?: string,
    zoneFileLookupURL?: string
  }): Promise<string> {
    return Promise.resolve()
      .then(() => {
        const appConfig = this.appConfig
        if (!appConfig) {
          throw new InvalidStateError('Missing AppConfig')
        }
        const defaults = {
          username: null,
          app: appConfig.appDomain,
          zoneFileLookupURL: null
        }
        return Object.assign({}, defaults, options)
      })
      .then((opts) => {
        if (opts.username) {
          return getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL)
        } else {
          return getOrSetLocalGaiaHubConnection(this)
            .then(gaiaHubConfig => getFullReadUrl(path, gaiaHubConfig))
        }
      })
      .then(readUrl => {
        if (!readUrl) {
          throw new Error('Missing readURL')
        } else {
          return readUrl
        }
      })
  }

  /**
   * List the set of files in this application's Gaia storage bucket.
   * @param {function} callback - a callback to invoke on each named file that
   * returns `true` to continue the listing operation or `false` to end it
   * @return {Promise} that resolves to the number of files listed
   */
  listFiles(callback: (name: string) => boolean): Promise<number> {
    return getOrSetLocalGaiaHubConnection(this)
      .then(gaiaHubConfig => this.listFilesLoop(gaiaHubConfig, null, 0, 0, callback))
  }

  /**
   * Deletes the specified file from the app's data store. Currently not implemented.
   * @param {String} path - the path to the file to delete
   * @returns {Promise} that resolves when the file has been removed
   * or rejects with an error
   * @private
   */
  deleteFile(path: string) {
    Promise.reject(new Error(`Delete of ${path} not supported by gaia hubs`))
  }
}
