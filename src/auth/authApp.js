/* @flow */
import queryString from 'query-string'
import { decodeToken } from 'jsontokens'
import protocolCheck from 'custom-protocol-detection-blockstack'
import { verifyAuthResponse } from './index'
import { BLOCKSTACK_HANDLER, isLaterVersion, hexStringToECPair } from '../utils'
import { getAddressFromDID } from '../index'
import { InvalidStateError, LoginFailedError } from '../errors'
import { decryptPrivateKey } from './authMessages'
import {
  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,
  DEFAULT_BLOCKSTACK_HOST,
  NAME_LOOKUP_PATH,
  DEFAULT_SCOPE
} from './authConstants'

import { extractProfile } from '../profiles'

import type { UserSession } from './userSession'
import { config } from '../config'

import { Logger } from '../logger'

const DEFAULT_PROFILE = {
  '@type': 'Person',
  '@context': 'http://schema.org'
}

/**
 * Check if a user is currently signed in.
 * @method isUserSignedIn
 * @return {Boolean} `true` if the user is signed in, `false` if not.
 */
export function isUserSignedIn() {
  console.warn(`DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in \
the next major release of blockstack.js. Create an instance of UserSession and call the \
instance method isUserSignedIn().`)
  const userSession = new blockstack.UserSession()
  return userSession.isUserSignedIn()
}

/**
 * Redirects the user to the Blockstack browser to approve the sign in request
 * given.
 *
 * The user is redirected to the `blockstackIDHost` if the `blockstack:`
 * protocol handler is not detected. Please note that the protocol handler detection
 * does not work on all browsers.
 * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
 * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
 *                                     protocol handler is not detected
 * @return {void}
 */
export function redirectToSignInWithAuthRequest(authRequest: string,
                                                blockstackIDHost: string =
                                                DEFAULT_BLOCKSTACK_HOST) {
  console.warn(`DEPRECATION WARNING: The static redirectToSignInWithAuthRequest() function will \
be deprecated in the next major release of blockstack.js. Create an instance of UserSession \
and call the instance method redirectToSignInWithAuthRequest().`)
  const userSession = new blockstack.UserSession()
  userSession.redirectToSignInWithAuthRequest(authRequest, blockstackIDHost)
}

/**
 * Generates an authentication request and redirects the user to the Blockstack
 * browser to approve the sign in request.
 *
 * Please note that this requires that the web browser properly handles the
 * `blockstack:` URL protocol handler.
 *
 * Most applications should use this
 * method for sign in unless they require more fine grained control over how the
 * authentication request is generated. If your app falls into this category,
 * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.
 *
 * @param {String} [redirectURI=`${window.location.origin}/`]
 * The location to which the identity provider will redirect the user after
 * the user approves sign in.
 * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]
 * Location of the manifest file.
 * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to
 * this app's data store.
 * An array of strings indicating which permissions this app is requesting.
 * @return {void}
 */
export function redirectToSignIn(redirectURI: string = `${window.location.origin}/`,
                                 manifestURI: string = `${window.location.origin}/manifest.json`,
                                 scopes: Array<string> = DEFAULT_SCOPE) {
  console.warn(`DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the \
next major release of blockstack.js. Create an instance of UserSession and call the \
instance method redirectToSignIn().`)
    const userSession = new blockstack.UserSession()
    userSession.redirectToSignIn()
}

/**
 * Check if there is a authentication request that hasn't been handled.
 * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
 */
export function isSignInPending() {
  console.warn(`DEPRECATION WARNING: The static isSignInPending() function will be deprecated in the \
next major release of blockstack.js. Create an instance of UserSession and call the \
instance method isSignInPending().`)
  const userSession = new blockstack.UserSession()
  return userSession.isSignInPending()
}

/**
 * Try to process any pending sign in request by returning a `Promise` that resolves
 * to the user data object if the sign in succeeds.
 *
 * @param {String} nameLookupURL - the endpoint against which to verify public
 * keys match claimed username
 * @param {String} authResponseToken - the signed authentication response token
 * @param {String} transitKey - the transit private key that corresponds to the transit public key
 * that was provided in the authentication request
 * @return {Promise} that resolves to the user data object if successful and rejects
 * if handling the sign in request fails or there was no pending sign in request.
 */
export function handlePendingSignIn(nameLookupURL: string = '',
                                    authResponseToken: string = getAuthResponseToken(),
                                    transitKey: string = '') {
  console.warn(`DEPRECATION WARNING: The static handlePendingSignIn() function will be deprecated in the \
next major release of blockstack.js. Create an instance of UserSession and call the \
instance method handlePendingSignIn().`)
  console.warn(`DEPRECATION WARNING: handlePendingSignIn() no long supports setting of nameLookupURL and \
transitKey. The nameLookupURL and transitKey now defaults to values in the default user session.`)
  const userSession = new blockstack.UserSession()
  userSession.handlePendingSignIn(authResponseToken)
}

/**
 * Retrieve the authentication token from the URL query
 * @return {String} the authentication token if it exists otherwise `null`
 */
function getAuthResponseToken(): string {
  const queryDict = queryString.parse(location.search)
  return queryDict.authResponse ? queryDict.authResponse : ''
}

/**
 * Retrieves the user data object. The user's profile is stored in the key `profile`.
 * @return {Object} User data object.
 */
export function loadUserData() {
  console.warn(`DEPRECATION WARNING: The static loadUserData() function will be deprecated in the \
next major release of blockstack.js. Create an instance of UserSession and call the \
instance method loadUserData().`)
  const userSession = new blockstack.UserSession()
  return userSession.loadUserData()
}

/**
 * Sign the user out and optionally redirect to given location.
 * @param  {String} [redirectURL=null] Location to redirect user to after sign out.
 * @return {void}
 */
export function signUserOut(redirectURL: ?string = null) {
  console.warn(`DEPRECATION WARNING: The static signUserOut() function will be deprecated in the \
next major release of blockstack.js. Create an instance of UserSession and call the \
instance method signUserOut().`)
  const userSession = new blockstack.UserSession()
  return userSession.signUserOut()
}



/**
 * Redirects the user to the Blockstack browser to approve the sign in request
 * given.
 *
 * The user is redirected to the `blockstackIDHost` if the `blockstack:`
 * protocol handler is not detected. Please note that the protocol handler detection
 * does not work on all browsers.
 * @param  {UserSession} caller - the instance calling this method
 * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
 * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
 *                                     protocol handler is not detected
 * @return {void}
 * @private
 */
export function redirectToSignInWithAuthRequestImpl(caller: UserSession,
                                                    authRequest: string) {
  const protocolURI = `${BLOCKSTACK_HANDLER}:${authRequest}`

  let httpsURI = `${DEFAULT_BLOCKSTACK_HOST}?authRequest=${authRequest}`

  if (caller.appConfig
      && caller.appConfig.authenticatorURL) {
    httpsURI = `${caller.appConfig.authenticatorURL}?authRequest=${authRequest}`
  }

  // If they're on a mobile OS, always redirect them to HTTPS site
  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
    Logger.info('detected mobile OS, sending to https')
    window.location = httpsURI
    return
  }

  function successCallback() {
    Logger.info('protocol handler detected')
    // protocolCheck should open the link for us
  }

  function failCallback() {
    Logger.warn('protocol handler not detected')
    window.location = httpsURI
  }

  function unsupportedBrowserCallback() {
    // Safari is unsupported by protocolCheck
    Logger.warn('can not detect custom protocols on this browser')
    window.location = protocolURI
  }

  protocolCheck(protocolURI, failCallback, successCallback, unsupportedBrowserCallback)
}

/**
 * Generates an authentication request and redirects the user to the Blockstack
 * browser to approve the sign in request.
 *
 * Please note that this requires that the web browser properly handles the
 * `blockstack:` URL protocol handler.
 *
 * Most web applications should use this
 * method for sign in unless they require more fine grained control over how the
 * authentication request is generated. If your app falls into this category,
 * use `makeAuthRequest`,
 * and `redirectToSignInWithAuthRequest` to build your own sign in process.
 * @param {UserSession} caller - the instance calling this function
 * @return {void}
 * @private
 */
export function redirectToSignInImpl(caller: UserSession) {
  const transitKey = caller.generateAndStoreTransitKey()
  const authRequest = caller.makeAuthRequest(transitKey)
  redirectToSignInWithAuthRequestImpl(caller, authRequest)
}


/**
 * Try to process any pending sign in request by returning a `Promise` that resolves
 * to the user data object if the sign in succeeds.
 *
 * @param {UserSession} caller - the instance calling this function
 * @param {String} authResponseToken - the signed authentication response token
 * @return {Promise} that resolves to the user data object if successful and rejects
 * if handling the sign in request fails or there was no pending sign in request.
 * @private
 */
export function handlePendingSignInImpl(caller: UserSession,
                                        authResponseToken: string) {
  const transitKey = caller.store.getSessionData().transitKey
  const coreNodeSessionValue = caller.store.getSessionData().coreNode
  let nameLookupURL = null

  if (!coreNodeSessionValue) {
    const tokenPayload = decodeToken(authResponseToken).payload
    if (isLaterVersion(tokenPayload.version, '1.3.0')
       && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {
      // override globally
      Logger.info(`Overriding ${config.network.blockstackAPIUrl} `
        + `with ${tokenPayload.blockstackAPIUrl}`)
      config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl
    }
    nameLookupURL = `${config.network.blockstackAPIUrl}${NAME_LOOKUP_PATH}`
  } else {
    nameLookupURL = `${coreNodeSessionValue}${NAME_LOOKUP_PATH}`
  }
  return verifyAuthResponse(authResponseToken, nameLookupURL)
    .then((isValid) => {
      if (!isValid) {
        throw new LoginFailedError('Invalid authentication response.')
      }
      const tokenPayload = decodeToken(authResponseToken).payload
      // TODO: real version handling
      let appPrivateKey = tokenPayload.private_key
      let coreSessionToken = tokenPayload.core_token
      if (isLaterVersion(tokenPayload.version, '1.1.0')) {
        if (transitKey !== undefined && transitKey != null) {
          if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {
            try {
              appPrivateKey = decryptPrivateKey(transitKey, tokenPayload.private_key)
            } catch (e) {
              Logger.warn('Failed decryption of appPrivateKey, will try to use as given')
              try {
                hexStringToECPair(tokenPayload.private_key)
              } catch (ecPairError) {
                throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means'
                                         + ' that the transit key has changed during login.')
              }
            }
          }
          if (coreSessionToken !== undefined && coreSessionToken !== null) {
            try {
              coreSessionToken = decryptPrivateKey(transitKey, coreSessionToken)
            } catch (e) {
              Logger.info('Failed decryption of coreSessionToken, will try to use as given')
            }
          }
        } else {
          throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit'
                                   + ' key, and none found.')
        }
      }
      let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL
      let gaiaAssociationToken
      if (isLaterVersion(tokenPayload.version, '1.2.0')
        && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {
        hubUrl = tokenPayload.hubUrl
      }
      if (isLaterVersion(tokenPayload.version, '1.3.0')
        && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {
        gaiaAssociationToken = tokenPayload.associationToken
      }

      const userData = {
        username: tokenPayload.username,
        profile: tokenPayload.profile,
        decentralizedID: tokenPayload.iss,
        identityAddress: getAddressFromDID(tokenPayload.iss),
        appPrivateKey,
        coreSessionToken,
        authResponseToken,
        hubUrl,
        gaiaAssociationToken
      }
      const profileURL = tokenPayload.profile_url
      if ((userData.profile === null
         || userData.profile === undefined)
        && profileURL !== undefined && profileURL !== null) {
        return fetch(profileURL)
          .then((response) => {
            if (!response.ok) { // return blank profile if we fail to fetch
              userData.profile = Object.assign({}, DEFAULT_PROFILE)
              const sessionData = caller.store.getSessionData()
              sessionData.userData = userData
              caller.store.setSessionData(sessionData)
              return userData
            } else {
              return response.text()
                .then(responseText => JSON.parse(responseText))
                .then(wrappedProfile => extractProfile(wrappedProfile[0].token))
                .then((profile) => {
                  const sessionData = caller.store.getSessionData()
                  userData.profile = profile
                  sessionData.userData = userData
                  caller.store.setSessionData(sessionData)
                  return userData
                })
            }
          })
      } else {
        const sessionData = caller.store.getSessionData()
        userData.profile = tokenPayload.profile
        sessionData.userData = userData
        caller.store.setSessionData(sessionData)
        return userData
      }
    })
}

/**
 * Retrieves the user data object. The user's profile is stored in the key `profile`.
 *
 *  @param {UserSession} caller - the instance calling this function
 *  @return {Object} User data object.
 *  @private
 */
export function loadUserDataImpl(caller: UserSession) {
  const userData = caller.store.getSessionData().userData
  if (!userData) {
    throw new InvalidStateError('No user data found. Did the user sign in?')
  }
  return userData
}
