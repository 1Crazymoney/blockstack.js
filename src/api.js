/* @flow */
import queryString from 'query-string'
import { AppConfig } from './auth/appConfig'
import { BlockstackSession } from './session'
import type { BlockstackSessionOptions } from './session'
import {
  redirectToSignInImpl,
  redirectToSignInWithAuthRequestImpl,
  handlePendingSignInImpl,
  loadUserDataImpl
} from './auth/authApp'

import {
  makeAuthRequestImpl,
  generateTransitKey
} from './auth/authMessages'

import {
  DEFAULT_BLOCKSTACK_HOST
} from './auth/authConstants'

import {
  decryptContentImpl,
  encryptContentImpl
} from './storage'
import {
  nextHour
} from './utils'

/**
 * abc
 * [session description]
 * @type {[type]}
 */
export class Blockstack {
  session: BlockstackSession

  constructor(initialValue: AppConfig) {
    const sessionOptions: BlockstackSessionOptions = {
      appConfig: initialValue
    }
    this.session = new BlockstackSession(sessionOptions)
  }

  /* AUTHENTICATION */

  /**
   * Generates an authentication request and redirects the user to the Blockstack
   * browser to approve the sign in request.
   *
   * Please note that this requires that the web browser properly handles the
   * `blockstack:` URL protocol handler.
   *
   * Most applications should use this
   * method for sign in unless they require more fine grained control over how the
   * authentication request is generated. If your app falls into this category,
   * use `generateAndStoreTransitKey`, `makeAuthRequest`,
   * and `redirectToSignInWithAuthRequest` to build your own sign in process.
   *
   * @return {void}
   */
  redirectToSignIn() {
    return redirectToSignInImpl(this)
  }

  /**
   * Redirects the user to the Blockstack browser to approve the sign in request
   * given.
   *
   * The user is redirected to the `blockstackIDHost` if the `blockstack:`
   * protocol handler is not detected. Please note that the protocol handler detection
   * does not work on all browsers.
   * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
   * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
   *                                     protocol handler is not detected
   * @return {void}
   */
  redirectToSignInWithAuthRequest(authRequest: string,
                                  blockstackIDHost: string
                                  = DEFAULT_BLOCKSTACK_HOST) {
    return redirectToSignInWithAuthRequestImpl(authRequest, blockstackIDHost)
  }

  /**
   * Generates an authentication request that can be sent to the Blockstack
   * browser for the user to approve sign in. This authentication request can
   * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
   * method.
   *
   * *Note: This method should only be used if you want to roll your own authentication
   * flow. Typically you'd use `redirectToSignIn` which takes care of this
   * under the hood.*
   * @param {string} transitKey - hex-encoded transit key
   * @param {Number} expiresAt - the time at which this request is no longer valid
   * @return {String} the authentication request
   * @private
   */
  makeAuthRequest(transitKey: string,
                  expiresAt: number = nextHour().getTime()): string {
    const appConfig = this.session.appConfig
    const redirectURI = appConfig.redirectURI()
    const manifestURI = appConfig.manifestURI()
    const scopes = appConfig.scopes
    const appDomain = appConfig.appDomain
    return makeAuthRequestImpl(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt)
  }

  /**
   * Generates a ECDSA keypair to
   * use as the ephemeral app transit private key
   * and store in the session
   * @return {String} the hex encoded private key
   *
   */
  generateAndStoreTransitKey() {
    const transitKey = generateTransitKey()
    this.session.transitKey = transitKey
    return transitKey
  }


  /**
   * Retrieve the authentication token from the URL query
   * @return {String} the authentication token if it exists otherwise `null`
   */
  getAuthResponseToken(): string {
    const queryDict = queryString.parse(location.search)
    return queryDict.authResponse ? queryDict.authResponse : ''
  }

  /**
   * Check if there is a authentication request that hasn't been handled.
   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
   */
  isSignInPending() {
    return !!this.getAuthResponseToken()
  }

  /**
   * Try to process any pending sign in request by returning a `Promise` that resolves
   * to the user data object if the sign in succeeds.
   *
   * @param {String} authResponseToken - the signed authentication response token
   * @return {Promise} that resolves to the user data object if successful and rejects
   * if handling the sign in request fails or there was no pending sign in request.
   */
  handlePendingSignIn(authResponseToken: string = this.getAuthResponseToken()) {
    return handlePendingSignInImpl(this, authResponseToken)
  }

  /**
   * Retrieves the user data object. The user's profile is stored in the key `profile`.
   * @return {Object} User data object.
   */
  loadUserData() {
    return loadUserDataImpl(this)
  }

  // isUserSignedIn
  // signUserOut
  // makeAuthRequest
  //
  //
  // /* PROFILES */
  // extractProfile
  // wrapProfileToken
  // signProfileToken
  // verifyProfileToken
  // validateProofs
  // lookupProfile
  //
  /* STORAGE */
  //
  // getFile
  // putFile

  /**
   * Encrypts the data provided with the app public key.
   * @param {String|Buffer} content - data to encrypt
   * @param {Object} [options=null] - options object
   * @param {String} options.publicKey - the hex string of the ECDSA public
   * key to use for encryption. If not provided, will use user's appPrivateKey.
   * @return {String} Stringified ciphertext object
   */
  encryptContent(content: string | Buffer,
                 options?: {publicKey?: string}) {
    return encryptContentImpl(this, content, options)
  }

  /**
   * Decrypts data encrypted with `encryptContent` with the
   * transit private key.
   * @param {String|Buffer} content - encrypted content.
   * @param {Object} [options=null] - options object
   * @param {String} options.privateKey - the hex string of the ECDSA private
   * key to use for decryption. If not provided, will use user's appPrivateKey.
   * @return {String|Buffer} decrypted content.
   */
  decryptContent(content: string, options?: {privateKey?: ?string}) {
    return decryptContentImpl(this, content, options)
  }

  // getAppBucketUrl
  // getUserAppFileUrl
}
